<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description></description>
		<link>http://collectivecognition.com</link>
		<atom:link href="http://collectivecognition.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Awesome Screenshots In Awesomewm</title>
				<description>&lt;p&gt;I’ve been experimenting with setting up an &lt;a href=&#39;https://www.archlinux.org&#39;&gt;arch linux&lt;/a&gt; work environment on my laptop this weekend and one of the things I found myself missing almost immediately from OSX was the handy-dandy built in screenshot functionality.&lt;/p&gt;

&lt;p&gt;In the spirit of open source, I whipped up a quick lua key-binding for &lt;a href=&#39;http://awesome.naquadah.org/&#39;&gt;awesome window manager&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just place the following in an apppropriate place in your &lt;code&gt;~/.config/rc.lua&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awful.key({ modkey, }, &amp;quot;p&amp;quot;, function () awful.util.spawn_with_shell(&amp;quot;FILENAME=/tmp/
$(date +%m-%d-%y-%H-%M-%S).png; import -window root \&amp;quot;$FILENAME\&amp;quot;; gimp \&amp;quot;$FILENAME\&amp;quot;&amp;quot;) end)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll need &lt;a href=&#39;http://www.imagemagick.org/&#39;&gt;imagemagick&lt;/a&gt; to take the actual screenshot and &lt;a href=&#39;http://www.gimp.org/&#39;&gt;gimp&lt;/a&gt; to view / edit it.&lt;/p&gt;

&lt;p&gt;Install them like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pacman -S imagemagick gimp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can restart &lt;code&gt;awesome&lt;/code&gt; by pressing &lt;code&gt;mod4-shift-r&lt;/code&gt;, by default.&lt;/p&gt;

&lt;p&gt;Now just press &lt;code&gt;mod4-p&lt;/code&gt; and a screenshot of your current view will auto-magically be opened in gimp.&lt;/p&gt;</description>
				<pubDate>Fri, 18 Apr 2014 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/awesome-screenshots-in-awesomewm</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/awesome-screenshots-in-awesomewm</guid>
			</item>
		
			<item>
				<title>Mock Http Backends In Angular</title>
				<description>&lt;p&gt;A quick introduction to implementing mock-HTTP backends in angular.js, a great technique that can help development in the absense of a backend, offline development, end-to-end testing and more.&lt;/p&gt;

&lt;p&gt;Include both &lt;code&gt;angular&lt;/code&gt; and the &lt;code&gt;angular-mocks&lt;/code&gt; library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;js/lib/angular.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;js/lib/angular-mocks.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bootstrap your application and conditionally inject &lt;code&gt;angular-mocks&lt;/code&gt; into your application module. I like to configure things this way to allow easily switching between live and mock backends when developing, testing, etc..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG = {
    useMocks: true
};

var yourApp = angular.module(&amp;quot;YourApp&amp;quot;, [CONFIG.useMocks ? &amp;quot;ngMockE2E&amp;quot; :function(){ }]);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s intercept some HTTP requests!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yourApp.run([&amp;quot;$httpBackend&amp;quot;, function($httpBackend){
    if(CONFIG.useMocks){

        // Respond to requests to `/foo` with `{&amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;}`:

        $httpBackend.whenGET(/^\/foo$/).respond(function(method, uri, body){
                return [200, {
                    foo: bar
                }];
            });

        // Respond to requests to `/foo/BAR` with `{&amp;quot;foo&amp;quot;: &amp;quot;BAR&amp;quot;}`:
        // Also throw an exception if the passed value is too short

        $httpBackend.whenGET(/^\/foo\/\w+$/).respond(function(method, uri, body){
            body = JSON.parse(body);
            
            if(body.foo.length &amp;gt; 2){
                return [200, {
                    foo: body.foo
                }];
            }

            return [500, &amp;quot;There was an error!&amp;quot;];
        });
    }
}]);&lt;/code&gt;&lt;/pre&gt;</description>
				<pubDate>Tue, 04 Feb 2014 00:00:00 -0500</pubDate>
				<link>http://collectivecognition.com/blog/mock-http-backends-in-angular</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/mock-http-backends-in-angular</guid>
			</item>
		
			<item>
				<title>Cancelling Outstanding Http Requests In Angular</title>
				<description>&lt;p&gt;While working on an angular.js project recently I ran into issues with long running http requests initiated by controllers that had since been destroyed causing subsequent requests to be delayed until they completed. To further complicate things, each browser support a different number of concurrent http requests, so behavior can is often erratic.&lt;/p&gt;

&lt;p&gt;In a traditional web application, these requests would be destroyed by the browser when navigating to a new page, but in a single page web application no such cleanup happens and we’re left to handle things on our own.&lt;/p&gt;

&lt;p&gt;Luckily a recent build of angular added support for cancelling of outstanding $http requests via the &lt;code&gt;timeout&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;Here’s a quick example implementation that demonstrates cancelling multiple outstanding $http requests when the controller is destroyed (such as when navigating to a new view):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&amp;quot;App&amp;quot;).
    controller(&amp;quot;SomeCtrl&amp;quot;, [&amp;quot;$scope&amp;quot;, $http&amp;quot;, $q&amp;quot;, function($scope, $http, $q){
        // Initiate a long running http request
        $http.get(&amp;quot;http://example.com/endpoint&amp;quot;, {
            timeout: $scope.canceler.promise
        });

        // And another one
        $http.get(&amp;quot;http://example.com/another_endpoint&amp;quot;, {
            timeout: $scope.canceler.promise
        });

        // Wait for the controller to be destroyed
        $scope.$on(&amp;quot;$destroy&amp;quot;, function(){
            // Cancel all outstanding $http requests
            // Multiple requests can share the same timeout promise
            $scope.canceler.resolve();
        });
    }]);&lt;/code&gt;&lt;/pre&gt;</description>
				<pubDate>Mon, 13 Jan 2014 00:00:00 -0500</pubDate>
				<link>http://collectivecognition.com/blog/cancelling-outstanding-http-requests-in-angular</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/cancelling-outstanding-http-requests-in-angular</guid>
			</item>
		
			<item>
				<title>Vr City</title>
				<description>&lt;p&gt;&lt;a href=&#39;/images/blog/original/vrcity-wip-2013-7-31.jpg&#39; rel=&#39;shadowbox&#39;&gt;&lt;img src=&#39;/images/blog/thumbnails/vrcity-wip-2013-7-31.jpg&#39; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Some very early work on a procedurally generated city for the Oculus Rift.&lt;/p&gt;</description>
				<pubDate>Wed, 31 Jul 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/VR-City</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/VR-City</guid>
			</item>
		
			<item>
				<title>Rss Feed And New Portfolio Page</title>
				<description>&lt;p&gt;I’ve made a few small updates to the site today, including the addition of an &lt;a href=&quot;/feed&quot;&gt;RSS feed&lt;/a&gt; and a new page to house my &lt;a href=&quot;/web&quot;&gt;web portfolio&lt;/a&gt;. There are only a few projects listed for now, but I’ll be updating it constantly as I bring projects over to the new infrastructure I’m in the process of building.&lt;/p&gt;</description>
				<pubDate>Tue, 16 Jul 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/rss-feed-and-new-portfolio-page</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/rss-feed-and-new-portfolio-page</guid>
			</item>
		
			<item>
				<title>Computational Complexity For Dummies</title>
				<description>&lt;p&gt;Dionysis “dionyziz” Zindros has written a &lt;a href=&quot;http://discrete.gr/complexity/&quot;&gt;great post on discrete.gr&lt;/a&gt; tackling the topic of algorithm complexity analysis for those of us who come from a non-CS background.&lt;/p&gt;

&lt;p&gt;It’s very well written and provides a great overview of the concepts involved.&lt;/p&gt;</description>
				<pubDate>Fri, 12 Jul 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/computational-complexity-for-dummies</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/computational-complexity-for-dummies</guid>
			</item>
		
			<item>
				<title>Keeping Ghpages In Sync With Master</title>
				<description>&lt;p&gt;For simple, static web projects, you may simply want to keep your gh-pages branch in sync with the master branch.&lt;/p&gt;

&lt;p&gt;It turns out this is exceedingly simple to do, adding only a few commands to your workflow.&lt;/p&gt;

&lt;p&gt;First, while your master branch is checked out, make sure all of your changes are committed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a -m &amp;quot;Some changes&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if you haven’t already, create the gh-pages branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b gh-pages&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you’ve already got a branch set up, just switch to it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout gh-pages&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The git &lt;code&gt;rebase&lt;/code&gt; command lets you copy the contents of one branch to another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, push out the changes in both branches:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push --all&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to switch back to the master branch when you’re done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout master&lt;/code&gt;&lt;/pre&gt;</description>
				<pubDate>Tue, 09 Jul 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/keeping-ghpages-in-sync-with-master</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/keeping-ghpages-in-sync-with-master</guid>
			</item>
		
			<item>
				<title>Obfuscating Sequential Ids With Skip32</title>
				<description>&lt;p&gt;Generally, ID generation schemes fall into one of two camps: sequential and random.&lt;/p&gt;

&lt;p&gt;Sequential provide obvious ease of implementation, where a random scheme will provide non-guessable IDs and a more complicated implementation due to the need to protect against collisions.&lt;/p&gt;

&lt;p&gt;One alternative that can give some of the best of both worlds is to use a hybrid approach where you generate sequential IDs, but encrypt them for display to the end-user using a non-trivial one-way encryption algorithm such as &lt;a href=&quot;https://npmjs.org/package/skip32&quot;&gt;skip32&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A sample implementation using node.js is below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var skip32 = new require(&amp;quot;skip32&amp;quot;).Skip32;
skip32 = new skip32([0x9b, 0x21, 0x96, 0xe, 0x1a, 0xcf, 0x24, 0x5f, 0x14, 0x93]);

var id = 0;
var generateID = function(){
	id++;
	return(skip32.encrypt(id).toString(16));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling &lt;code&gt;generateID&lt;/code&gt; repeatedly will result in a series of obfuscated sequential IDs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(generateID());
# 3d4a6194
console.log(generateID());
# 23e8cd4b&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the array passed to the skip32 constructor is a key in the form of a byte array and can be up to 10 bytes in length. You’ll want to change this for your own purposes and store it securely like any key.&lt;/p&gt;</description>
				<pubDate>Sat, 01 Jun 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/obfuscating-sequential-ids-with-skip32</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/obfuscating-sequential-ids-with-skip32</guid>
			</item>
		
			<item>
				<title>Socket.io And Node.js Clustering</title>
				<description>&lt;p&gt;I ran into a problem while working on chat.js, in the form of alot of log-spam from socket.io that looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info  - handshake authorized DL6P-B6mDjt1hrhM3VYw
debug - setting request GET /socket.io/1/websocket/DL6P-B6mDjt1hrhM3VYw
debug - set heartbeat interval for client DL6P-B6mDjt1hrhM3VYw
debug - websocket writing 7:::1+0
warn  - client not handshaken client should reconnect
info  - transport end (error)
debug - set close timeout for client DL6P-B6mDjt1hrhM3VYw
debug - cleared close timeout for client DL6P-B6mDjt1hrhM3VYw
debug - cleared heartbeat interval for client DL6P-B6mDjt1hrhM3VYw
debug - discarding transport&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem turned out to be due to my use of the (still experimental) &lt;code&gt;cluster&lt;/code&gt; API causing a race condition in socket.io and causing erratic behaviour in my application.&lt;/p&gt;

&lt;p&gt;Luckily, multiple-cpu support isn’t a huge requirement for me at this time. Just a heads up for anyone else having similar problems.&lt;/p&gt;</description>
				<pubDate>Wed, 29 May 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/socket.io-and-node.js-clustering</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/socket.io-and-node.js-clustering</guid>
			</item>
		
			<item>
				<title>Bare Minimum Javascript Tests</title>
				<description>&lt;p&gt;I had a need to write some quick and dirty tests for a javascript library I was working on and whipped up a minimal (one line) assertion function which fills all of my testing requirements on simple projects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var assert = function(test, description){ console.log(&amp;quot;[&amp;quot; + (test ? &amp;quot;PASS&amp;quot; : &amp;quot;FAIL&amp;quot;) + &amp;quot;] &amp;quot; + description); };&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assertions can be made like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert(true !== false, &amp;quot;True is not false&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will result in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[TRUE] True is not false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Throw the assert function and your tests together into &lt;code&gt;someTests.js&lt;/code&gt; and execute them: &lt;code&gt;node someTests&lt;/code&gt;.&lt;/p&gt;</description>
				<pubDate>Tue, 28 May 2013 00:00:00 -0400</pubDate>
				<link>http://collectivecognition.com/blog/bare-minimum-javascript-tests</link>
				<guid isPermaLink="true">http://collectivecognition.com/blog/bare-minimum-javascript-tests</guid>
			</item>
		
	</channel>
</rss>